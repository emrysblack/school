// implimentation of red-black tree

#ifndef REDBLACK_H
#define REDBLACK_H

#include <iostream>
template <class T>
class RBTree
{
  private:
   T data;          // --- data stored in node of tree
   RBTree* left;       // --- pointer to left subtree
   RBTree* right;      // --- pointer to right subtree
   RBTree* parent;     // --- pointer to the parent node;
   bool red;          // used for insert

  public:
   RBTree();
   RBTree(T item);
   ~RBTree(void);
   
   T getData(void);
   void setData(T item);

   void clear(void);
   void insert(T item); // uses internal functions to insert
   
   void insertLeft(T item);     // insert node to left
   void insertRight(T item);    // insert node to right
   RBTree* getLeftChild(void);     // return the ptr to the left child
   RBTree* getRightChild(void);    // return the ptr to the right child
   RBTree* getParent(void);        // return parent
   void setLeft(RBTree* tree);    
   void setRight(RBTree* tree);

   void infix(void);              // do infix traversal
   void prefix(void);             // do prefix traversal
   void postfix(void);            // do postfix traversal
   void level(void);              // do level order traversal
   
};


/**********************************************************************
 * constructor
 **********************************************************************/
template <class T>
RBTree<T>::RBTree()
{
   parent = NULL;
   right = NULL;
   left = NULL;
   red = true;
}

/**********************************************************************
 * constructor
 **********************************************************************/
template <class T>
RBTree<T>::RBTree(T item)
{
   parent = NULL;
   right = NULL;
   left = NULL;
   data = item;
   red = true;
}

/**********************************************************************
 * destructor uses postfix algorithm to delete nodesclear
 **********************************************************************/
template <class T>
RBTree<T>::~RBTree(void)
{
   clear();
}

/**********************************************************************
 * clear uses postfix algorithm to delete nodes
 **********************************************************************/
template <class T>
void RBTree<T>::clear(void)
{
   RBTree<T>* current = this;

   // infix through the tree to destroy from the bottom up
   if (current->left != NULL)
   {  
      current->left->clear();
   }
      
   if (current->right != NULL)
   {    
      current->right->clear();
   }

   // return the memory from the bottom up
   if (current != NULL)
   {
      if (current->left != NULL)
      {
         std::cerr << "destruct " << current->left->data << std::endl;
         delete current->left;
         current->left = NULL;
      }
      if (current->right != NULL)
      {
         std::cerr << "destruct " << current->right->data << std::endl;
         delete current->right;
         current->right = NULL;
      }
   }
}

/**********************************************************************
 * uses insert left and right to create nodes and handles balancing
 **********************************************************************/
template <class T>
void RBTree<T>::insert(T item)
{
   // insert left or right depending on value
   if (!right && !left && !parent) // root node
   {
      std::cerr << "root is " << item << std::endl;
      data = item;
      parent = this;
      return;
   }
   
   RBTree<T> * temp = this;
   bool found = false;
   while(!found)
   {
      if (item <= temp->data)
      {
         if(temp->left)
         {
            temp = temp->left;
         }
         else
         {
            std::cerr << "insert " << item
                      << " left of " << temp->data << std::endl;
            temp->insertLeft(item);
            found = true;
         }
      }
      else
      {
         if(temp->right)
         {
            temp = temp->right;
         }
         else
         {
            std::cerr << "insert " << item
                      << " right of " << temp->data << std::endl;
            temp->insertRight(item);
            found = true;
         }
      }
   }
   // check red-black status and rebalance
}

/**********************************************************************
 * creates a new node and inserts node to left
 **********************************************************************/
template <class T>
void RBTree<T>::insertLeft(T item)
{
   RBTree<T>* temp;
   temp = new RBTree<T>(item);
   left = temp;
   temp->parent = this;
}

/**********************************************************************
 * creates a new node and inserts node to right
 **********************************************************************/
template <class T>
void RBTree<T>::insertRight(T item)
{
   RBTree<T>* temp;
   temp = new RBTree<T>(item);
   right = temp;
   temp->parent = this;
}

/**********************************************************************
 * returns the pointer to the left child
 **********************************************************************/
template <class T>
RBTree<T>* RBTree<T>::getLeftChild(void)
{
   return left;
}

/**********************************************************************
 * returns the pointer to the right child
 **********************************************************************/
template <class T>
RBTree<T>* RBTree<T>::getRightChild(void)
{
   return right;
}

/**********************************************************************
 * returns pointer to the parent node
 **********************************************************************/
template <class T>
RBTree<T>* RBTree<T>::getParent(void)
{
   return parent;
}

/**********************************************************************
 * returns data of current node
 **********************************************************************/
template <class T>
T RBTree<T>::getData(void)
{
   return data;
}

/**********************************************************************
 * sets data of current node
 **********************************************************************/
template <class T>
void RBTree<T>::setData(T item)
{
   data = item;
}

/**********************************************************************
 * sets left child to node
 **********************************************************************/
template <class T>
void RBTree<T>::setLeft(RBTree<T>* tree)
{
   left = tree;
   if (left != NULL) left->parent = this;
}

/**********************************************************************
 * sets right child to node
 **********************************************************************/
template <class T>
void RBTree<T>::setRight(RBTree<T>* tree)
{
   right = tree;
   if (right != NULL) right->parent = this;
}

/**********************************************************************
 * do infix traversal
 **********************************************************************/
template <class T>
void RBTree<T>::infix(void)
{
   if (left != NULL) left->infix();
   std::cout << data << " ";
   if (right != NULL) right->infix();
}

/**********************************************************************
 * do prefix traversal
 **********************************************************************/
template <class T>
void RBTree<T>::prefix(void)
{
   std::cout << data << " ";
   if (left != NULL) left->prefix();
   if (right != NULL) right->prefix();
}

/**********************************************************************
 * do postfix traversal
 **********************************************************************/
template <class T>
void RBTree<T>::postfix(void)
{
   if (left != NULL) left->postfix();
   if (right != NULL) right->postfix();
   std::cout << data << " ";
}

/**********************************************************************
 * do level order traversal
 **********************************************************************/
template <class T>
void RBTree<T>::level(void)
{
   const int MAX = 50;
   RBTree *queue[MAX];
   RBTree *temp;
   int front = 0;
   int back = 0;

   queue[back++ ] = this;

   while (front != back)
   {
      temp = queue[front];
      front = (front + 1) % MAX;
      if (temp != NULL)
      {
         // visit
         std::cout.width(4);
         std::cout << temp->data << " ";
         if (temp->parent == NULL)
            std::cout << " Parent = NULL! " << std::endl;
         else
            std::cout << " Parent = " << temp->parent->data << "   "
                      << std::endl;
         // end Visit        
         queue[back] = temp->left;
         back = (back + 1) % MAX;
         queue[back] = temp->right;
         back = (back + 1) % MAX;

      }
   }
}

#endif
