// test for atoi
#include <iostream>
#include <string>
using namespace std;

const int MAX = 10;

template <class T>
class Deque
{
private:
   int front;
   int back;
   int num;
   T *items;
   int cap;

public:
   Deque(int size = 1); //constructor
   ~Deque(); // destructor
   Deque(const Deque<T> &rhs); // copy constructor
   Deque & operator = (const Deque<T> &rhs); // assignment operator
   void pushFront(T value);
   void popFront();
   void pushBack(T value);
   void popBack();
   void resize();
   void display();
   bool empty();
   bool full();
};

template <class T>
Deque<T>::Deque(int size)
{
   cap = size;
   items = new T[cap];
   front = 0;
   back = 0;
   num = 0;  
}

template <class T>
Deque<T>::~Deque()
{
   delete [] items;
}

template <typename T>
Deque<T>::Deque(const Deque <T> &rhs)
{
   cap = rhs.cap;
   items = new T[cap];
   front = 0;
   back = 0;
   num = 0;
   *this = rhs;
}

template <typename T>
Deque<T> & Deque<T>::operator=(const Deque <T> &rhs)
{
   if (cap != rhs.cap)
   {
      if (cap != 0) // should never be 0, but better safe than sorry
         delete [] items;
      cap = rhs.cap;
      items = new T[cap];
   }
   
   // reset
   front = 0;
   back = 0;
   num = 0;

   // copy over items in order
   for (int i = rhs.front, j = 0; j < rhs.num; i++, j++)
   {
      i %= rhs.cap;
      items[j] = rhs.items[i];
      back++;
      num++;
   }
    
   return *this;
}

template <class T>
void Deque<T>::pushFront(T value)
{
   if (full())
   {
      resize();
   }
   if (num != 0)
   {
      front += cap - 1;
      front %= cap;
   }
   items[front] = value;
   num++;
}

template <class T>
void Deque<T>::popFront()
{
   if (num != 0)
   {
      front ++;
      front %= cap;
      num--;
   }  
}

template <class T>
void Deque<T>::pushBack(T value)
{
   if (full())
   {
      resize();
   }
    
   if(num != 0)
   {
      back++;
      back %= cap;
   }
   items[back] = value;
   num++;
}

template <class T>
void Deque<T>::popBack()
{
   if (num != 0)
   {
      back += cap - 1;
      back %= cap;
      num--;
   }
}

template <class T>
void Deque<T>::resize()
{
   Deque <T> temp(*this); // hold old items
   front = 0; // reset
   back = 0;
   num = 0;
   delete [] items;
   cap *= 2; // reallocate
   items = new T[cap];

   // copy old items back in
   for (int i = temp.front, j = 0; j < temp.num; i++, j++)
   {
      i %= temp.cap;
      items[j] = temp.items[i];
      if (j != 0) // first item is 0 to match push functions
         back++;
      num++;
   }
}

template <class T>
void Deque<T>::display()
{
   cout << "--List--\n";
   for (int i = front, j = 0; j < num; i++, j++)
   {
      i %= cap;
      cout << "item at pos " << i  << "-> " << items[i] << endl;
   }
   cout << endl;
}

template <class T>
bool Deque<T>::empty()
{
   return num == 0;
}

template <class T>
bool Deque<T>::full()
{
   return num == cap;
}

int main(int argc, char** argv)
{
   Deque <string> deque;
   string names[] = {"Charles 0", "Charles 1", "Charles 2",
                     "Charles 3", "Charles 4"};
   for (int i = 0; i < MAX / 2; i++)
   {   
      cout << "pushing front\n";
      deque.pushFront(names[i]);   
   }
   
   for (int i = 0; i < MAX / 2; i++)
   {   
      cout << "pushing back\n";
      deque.pushBack(names[i]);
   }
   
   // deque.popFront();
   // deque.popBack();
   // deque.popBack();
   // deque.popBack();
   // deque.popBack();
   // deque.popBack();
   Deque <string> deque1(deque);
   Deque <string> deque2;
   deque2 = deque;
   deque.display();
   deque1.display();
   deque2.display();

   cout << "Full? " << (deque.full() ? "yes" : "no") << endl;
   cout << "Empty? " << (deque.empty() ? "yes" : "no") << endl;
   
   return 0;
}
