// test for atoi
#include <iostream>
#include <string>
using namespace std;

const int MAX = 10;

template <class T>
class Deque
{
private:
   int head;
   int tail;
   int num;
   T *items;
   int cap;

public:
   Deque(int size = 1); //constructor
   ~Deque(); // destructor
   Deque(const Deque<T> &rhs); // copy constructor
   Deque & operator = (const Deque<T> &rhs); // assignment operator
   void push_front(T value);
   inline void pop_front();
   void push_back(T value);
   inline void pop_back();
   void resize();
   void display();
   bool empty() {return num ==0;}
   bool full() {return num == cap;}
   int size() {return num;}
   int capacity() {return cap;}
   void clear() {head = 0; tail = 0; num = 0;}
   T front() {return items[head];}
   T back() {return items[tail];}
};

template <class T>
Deque<T>::Deque(int size)
{
   cap = size;
   items = new T[cap];
   head = 0;
   tail = 0;
   num = 0;  
}

template <class T>
Deque<T>::~Deque()
{
   delete [] items;
}

template <typename T>
Deque<T>::Deque(const Deque <T> &rhs)
{
   cap = rhs.cap;
   items = new T[cap];
   head = 0;
   tail = 0;
   num = 0;
   *this = rhs;
}

template <typename T>
Deque<T> & Deque<T>::operator=(const Deque <T> &rhs)
{
   if (cap != rhs.cap)
   {
      if (cap != 0) // should never be 0, but better safe than sorry
         delete [] items;
      cap = rhs.cap;
      items = new T[cap];
   }
   
   // reset
   head = 0;
   tail = 0;
   num = 0;

   // copy over items in order
   for (int i = rhs.head, j = 0; j < rhs.num; i++, j++)
   {
      i %= rhs.cap;
      items[j] = rhs.items[i];
      tail++;
      num++;
   }
    
   return *this;
}

template <class T>
void Deque<T>::push_front(T value)
{
   if (full())
   {
      resize();
   }
   if (num != 0)
   {
      head += cap - 1;
      head %= cap;
   }
   items[head] = value;
   num++;
}

template <class T>
void Deque<T>::pop_front()
{
   if (num != 0)
   {
      head ++;
      head %= cap;
      num--;
   }  
}

template <class T>
void Deque<T>::push_back(T value)
{
   if (full())
   {
      resize();
   }
    
   if(num != 0)
   {
      tail++;
      tail %= cap;
   }
   items[tail] = value;
   num++;
}

template <class T>
void Deque<T>::pop_back()
{
   if (num != 0)
   {
      tail += cap - 1;
      tail %= cap;
      num--;
   }
}

template <class T>
void Deque<T>::resize()
{
   Deque <T> temp(*this); // hold old items
   head = 0; // reset
   tail = 0;
   num = 0;
   delete [] items;
   cap *= 2; // reallocate
   items = new T[cap];

   // copy old items back in
   for (int i = temp.head, j = 0; j < temp.num; i++, j++)
   {
      i %= temp.cap;
      items[j] = temp.items[i];
      if (j != 0) // first item is 0 to match push functions
         tail++;
      num++;
   }
}

template <class T>
void Deque<T>::display()
{
   cout << "--List--\n";
   for (int i = head, j = 0; j < num; i++, j++)
   {
      i %= cap;
      cout << "item at pos " << i  << "-> " << items[i] << endl;
   }
   cout << endl;
}

int main(int argc, char** argv)
{
   Deque <string> deque;
   string names[] = {"Charles 0", "Charles 1", "Charles 2",
                     "Charles 3", "Charles 4"};
   for (int i = 0; i < MAX / 2; i++)
   {   
      cout << "pushing front\n";
      deque.push_front(names[i]);   
   }
   
   for (int i = 0; i < MAX / 2; i++)
   {   
      cout << "pushing back\n";
      deque.push_back(names[i]);
   }
   
   // deque.pop_front();
   // deque.pop_back();
   // deque.pop_back();
   // deque.pop_back();
   // deque.pop_back();
   // deque.pop_back();
   Deque <string> deque1(deque);
   Deque <string> deque2;
   deque2 = deque;
   deque2.clear();
   deque.display();
   deque1.display();
   deque2.display();

   cout << "Full? " << (deque.full() ? "yes" : "no") << endl;
   cout << "Empty? " << (deque.empty() ? "yes" : "no") << endl;
   
   return 0;
}
